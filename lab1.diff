diff --git a/hw/rtl/VX_config.vh b/hw/rtl/VX_config.vh
index eef7bed..50eb5b0 100644
--- a/hw/rtl/VX_config.vh
+++ b/hw/rtl/VX_config.vh
@@ -501,6 +501,10 @@
 `define LATENCY_FCVT 5
 `endif
 
+`ifndef LATENCY_DOT8
+`define LATENCY_DOT8 2
+`endif
+
 // FMA Bandwidth ratio
 `ifndef FMA_PE_RATIO
 `define FMA_PE_RATIO 1
diff --git a/hw/rtl/VX_gpu_pkg.sv b/hw/rtl/VX_gpu_pkg.sv
index f2f00ed..3f1860c 100644
--- a/hw/rtl/VX_gpu_pkg.sv
+++ b/hw/rtl/VX_gpu_pkg.sv
@@ -182,7 +182,7 @@ package VX_gpu_pkg;
     ///////////////////////////////////////////////////////////////////////////
 
     localparam INST_ALU_ADD =    4'b0000;
-    //localparam INST_ALU_UNUSED=4'b0001;
+    localparam INST_ALU_DOT8 =   4'b0001;
     localparam INST_ALU_LUI =    4'b0010;
     localparam INST_ALU_AUIPC =  4'b0011;
     localparam INST_ALU_SLTU =   4'b0100;
diff --git a/hw/rtl/VX_trace_pkg.sv b/hw/rtl/VX_trace_pkg.sv
index cfc12d6..022c6b8 100644
--- a/hw/rtl/VX_trace_pkg.sv
+++ b/hw/rtl/VX_trace_pkg.sv
@@ -91,6 +91,7 @@ package VX_trace_pkg;
                             endcase
                         end else begin
                             case (INST_ALU_BITS'(op_type))
+                                INST_ALU_DOT8:  `TRACE(level, ("DOT8"))
                                 INST_ALU_ADD:   `TRACE(level, ("ADD"))
                                 INST_ALU_SUB:   `TRACE(level, ("SUB"))
                                 INST_ALU_SLL:   `TRACE(level, ("SLL"))
diff --git a/hw/rtl/core/VX_alu_unit.sv b/hw/rtl/core/VX_alu_unit.sv
index 1b7f9b6..0626e1b 100644
--- a/hw/rtl/core/VX_alu_unit.sv
+++ b/hw/rtl/core/VX_alu_unit.sv
@@ -31,10 +31,11 @@ module VX_alu_unit import VX_gpu_pkg::*; #(
     localparam BLOCK_SIZE   = `NUM_ALU_BLOCKS;
     localparam NUM_LANES    = `NUM_ALU_LANES;
     localparam PARTIAL_BW   = (BLOCK_SIZE != `ISSUE_WIDTH) || (NUM_LANES != `SIMD_WIDTH);
-    localparam PE_COUNT     = 1 + `EXT_M_ENABLED;
+    localparam PE_COUNT     = 1 + `EXT_M_ENABLED + 1; 
     localparam PE_SEL_BITS  = `CLOG2(PE_COUNT);
     localparam PE_IDX_INT   = 0;
-    localparam PE_IDX_MDV   = PE_IDX_INT + `EXT_M_ENABLED;
+    localparam PE_IDX_MDV   = PE_IDX_INT + 1;
+    localparam PE_IDX_DOT8  = PE_IDX_INT + `EXT_M_ENABLED + 1;
 
     VX_execute_if #(
         .data_t (alu_exe_t)
@@ -68,8 +69,12 @@ module VX_alu_unit import VX_gpu_pkg::*; #(
         reg [`UP(PE_SEL_BITS)-1:0] pe_select;
         always @(*) begin
             pe_select = PE_IDX_INT;
-            if (`EXT_M_ENABLED && (per_block_execute_if[block_idx].data.op_args.alu.xtype == ALU_TYPE_MULDIV))
+            if (per_block_execute_if[block_idx].data.op_type == INST_OP_BITS'(INST_ALU_DOT8)) begin
+                pe_select = PE_IDX_DOT8;
+            end
+            else if (`EXT_M_ENABLED && (per_block_execute_if[block_idx].data.op_args.alu.xtype == ALU_TYPE_MULDIV)) begin
                 pe_select = PE_IDX_MDV;
+            end
         end
 
         VX_pe_switch #(
@@ -111,6 +116,16 @@ module VX_alu_unit import VX_gpu_pkg::*; #(
             .result_if  (pe_result_if[PE_IDX_MDV])
         );
     `endif
+
+    VX_alu_dot8 #(
+        .INSTANCE_ID (`SFORMATF(("%s-dot8%0d", INSTANCE_ID, block_idx))),
+        .NUM_LANES (NUM_LANES)
+    ) dot8_unit (
+        .clk        (clk),
+        .reset      (reset),
+        .execute_if (pe_execute_if[PE_IDX_DOT8]),
+        .result_if  (pe_result_if[PE_IDX_DOT8])
+    );
     end
 
     VX_gather_unit #(
diff --git a/hw/rtl/core/VX_decode.sv b/hw/rtl/core/VX_decode.sv
index 6669f26..733eb57 100644
--- a/hw/rtl/core/VX_decode.sv
+++ b/hw/rtl/core/VX_decode.sv
@@ -534,6 +534,23 @@ module VX_decode import VX_gpu_pkg::*; #(
                         endcase
                     end
                 `endif
+                    7'h03: begin
+                        case (funct3)
+                            3'h0: begin // DOT8
+                                ex_type = EX_ALU;
+                                op_type = INST_OP_BITS'(INST_ALU_DOT8);
+                                op_args.alu = '0;
+                                op_args.alu.xtype = ALU_TYPE_ARITH;
+                                op_args.alu.is_w    = 0;
+                                op_args.alu.use_PC  = 0;
+                                op_args.alu.use_imm = 0;
+                                `USED_IREG (rd);
+                                `USED_IREG (rs1);
+                                `USED_IREG (rs2);
+                            end
+                            default:;
+                        endcase
+                    end
                     default:;
                 endcase
             end
diff --git a/kernel/include/vx_intrinsics.h b/kernel/include/vx_intrinsics.h
index 71d4cd5..9a4662a 100644
--- a/kernel/include/vx_intrinsics.h
+++ b/kernel/include/vx_intrinsics.h
@@ -154,6 +154,15 @@ inline void vx_barrier(int barried_id, int num_warps) {
     __asm__ volatile (".insn r %0, 4, 0, x0, %1, %2" :: "i"(RISCV_CUSTOM0), "r"(barried_id), "r"(num_warps));
 }
 
+// dot8
+static inline int32_t vx_dot8(uint32_t a, uint32_t b){
+    int32_t rd;
+    asm volatile(".insn r 0x0B, 0, 3, %0, %1, %2"
+                 : "=r"(rd)
+                 : "r"(a), "r"(b));
+    return rd;
+}
+
 // Return current thread identifier
 inline __attribute__((const)) int vx_thread_id() {
     int ret;
diff --git a/sim/simx/decode.cpp b/sim/simx/decode.cpp
index f2d6cc3..5eb0993 100644
--- a/sim/simx/decode.cpp
+++ b/sim/simx/decode.cpp
@@ -112,6 +112,7 @@ static op_string_t op_string(const Instr &instr) {
         }
       }
       case AluType::CZERO: return {aluArgs.imm ? "CZERO.NEZ":"CZERO.EQZ", ""};
+      case AluType::DOT8: return {"VX_DOT8", ""};
       default:
         std::abort();
       }
@@ -1076,6 +1077,21 @@ void Emulator::decode(uint32_t code, uint32_t wid, uint64_t uuid) {
       }
       ibuffer.push_back(instr);
     } break;
+    case 3: {
+      switch (funct3) {
+      case 0: { // DOT8
+        auto instr = std::allocate_shared<Instr>(instr_pool_, uuid, FUType::ALU);
+        instr->setOpType(AluType::DOT8);
+        instr->setArgs(IntrAluArgs{0, 0, 0});         // 无立即数(imm)
+        instr->setDestReg(rd, RegType::Integer);      // rd: i32
+        instr->setSrcReg(0, rs1, RegType::Integer);   // rs1: 打包4×int8
+        instr->setSrcReg(1, rs2, RegType::Integer);   // rs2: 打包4×int8
+        ibuffer.push_back(instr);
+      } break;
+      default:
+        std::abort();
+      }
+    } break;
   #ifdef EXT_TCU_ENABLE
     case 2: {
       switch (funct3) {
diff --git a/sim/simx/execute.cpp b/sim/simx/execute.cpp
index 3829260..4e3d880 100644
--- a/sim/simx/execute.cpp
+++ b/sim/simx/execute.cpp
@@ -300,6 +300,31 @@ instr_trace_t* Emulator::execute(const Instr &instr, uint32_t wid) {
           rd_data[t].i = cond ? 0 : rs1_data[t].i;
         }
       } break;
+      case AluType::DOT8: {
+        for (uint32_t t = thread_start; t < num_threads; ++t) {
+          if (!warp.tmask.test(t))
+            continue;
+          uint32_t packedA = rs1_data[t].u;
+          uint32_t packedB = rs2_data[t].u;
+          
+          int8_t a0 = (int8_t)( packedA        & 0xFF);
+          int8_t a1 = (int8_t)((packedA >>  8) & 0xFF);
+          int8_t a2 = (int8_t)((packedA >> 16) & 0xFF);
+          int8_t a3 = (int8_t)((packedA >> 24) & 0xFF);
+
+          int8_t b0 = (int8_t)( packedB        & 0xFF);
+          int8_t b1 = (int8_t)((packedB >>  8) & 0xFF);
+          int8_t b2 = (int8_t)((packedB >> 16) & 0xFF);
+          int8_t b3 = (int8_t)((packedB >> 24) & 0xFF);
+
+          int32_t sum = (int32_t)a0 * (int32_t)b0
+                  + (int32_t)a1 * (int32_t)b1
+                  + (int32_t)a2 * (int32_t)b2
+                  + (int32_t)a3 * (int32_t)b3;
+          DP(3, "*** DOT8[" << t << "]: a=0x" << std::hex << packedA << ", b=0x" << packedB << ", c=0x" << sum << std::dec);
+          rd_data[t].i = sum;
+        }
+      } break;
       default:
         std::abort();
       }
diff --git a/sim/simx/func_unit.cpp b/sim/simx/func_unit.cpp
index 42cbeb9..8d715f5 100644
--- a/sim/simx/func_unit.cpp
+++ b/sim/simx/func_unit.cpp
@@ -53,6 +53,9 @@ void AluUnit::tick() {
 			case AluType::CZERO:
 				delay = 2;
 				break;
+			case AluType::DOT8:
+				delay = 2;
+				break;
 			default:
 				std::abort();
 			}
diff --git a/sim/simx/types.h b/sim/simx/types.h
index d069bda..e6904b1 100644
--- a/sim/simx/types.h
+++ b/sim/simx/types.h
@@ -169,7 +169,8 @@ enum class AluType {
   AND,
   OR,
   XOR,
-  CZERO
+  CZERO,
+  DOT8,
 };
 
 struct IntrAluArgs {
@@ -193,6 +194,7 @@ inline std::ostream &operator<<(std::ostream &os, const AluType& type) {
   case AluType::OR:      os << "OR"; break;
   case AluType::XOR:     os << "XOR"; break;
   case AluType::CZERO:   os << "CZERO"; break;
+  case AluType::DOT8:    os << "DOT8"; break;
   default:
     assert(false);
   }
diff --git a/tests/regression/Makefile b/tests/regression/Makefile
index be3ccc9..1c19fca 100644
--- a/tests/regression/Makefile
+++ b/tests/regression/Makefile
@@ -1,86 +1,14 @@
-ROOT_DIR := $(realpath ../..)
+ROOT_DIR := $(realpath ../../..)
 include $(ROOT_DIR)/config.mk
 
-all:
-	$(MAKE) -C basic
-	$(MAKE) -C demo
-	$(MAKE) -C dogfood
-	$(MAKE) -C dropout
-	$(MAKE) -C dotproduct
-	$(MAKE) -C mstress
-	$(MAKE) -C io_addr
-	$(MAKE) -C printf
-	$(MAKE) -C diverge
-	$(MAKE) -C sort
-	$(MAKE) -C fence
-	$(MAKE) -C vecadd
-	$(MAKE) -C sgemm
-	$(MAKE) -C conv3
-	$(MAKE) -C relu
-	$(MAKE) -C sgemv
-	$(MAKE) -C sgemm2
-	$(MAKE) -C madmax
-	$(MAKE) -C stencil3d
+PROJECT := sgemm
 
-run-simx:
-	$(MAKE) -C basic run-simx
-	$(MAKE) -C demo run-simx
-	$(MAKE) -C dogfood run-simx
-	$(MAKE) -C dropout run-simx
-	$(MAKE) -C dotproduct run-simx
-	$(MAKE) -C mstress run-simx
-	$(MAKE) -C io_addr run-simx
-	$(MAKE) -C printf run-simx
-	$(MAKE) -C diverge run-simx
-	$(MAKE) -C sort run-simx
-	$(MAKE) -C fence run-simx
-	$(MAKE) -C vecadd run-simx
-	$(MAKE) -C sgemm run-simx
-	$(MAKE) -C conv3 run-simx
-	$(MAKE) -C relu run-simx
-	$(MAKE) -C sgemv run-simx
-	$(MAKE) -C sgemm2 run-simx
-	$(MAKE) -C madmax run-simx
-	$(MAKE) -C stencil3d run-simx
+SRC_DIR := $(VORTEX_HOME)/tests/regression/$(PROJECT)
 
-run-rtlsim:
-	$(MAKE) -C basic run-rtlsim
-	$(MAKE) -C demo run-rtlsim
-	$(MAKE) -C dogfood run-rtlsim
-	$(MAKE) -C dropout run-rtlsim
-	$(MAKE) -C dotproduct run-rtlsim
-	$(MAKE) -C mstress run-rtlsim
-	$(MAKE) -C io_addr run-rtlsim
-	$(MAKE) -C printf run-rtlsim
-	$(MAKE) -C diverge run-rtlsim
-	$(MAKE) -C sort run-rtlsim
-	$(MAKE) -C fence run-rtlsim
-	$(MAKE) -C vecadd run-rtlsim
-	$(MAKE) -C sgemm run-rtlsim
-	$(MAKE) -C conv3 run-rtlsim
-	$(MAKE) -C relu run-rtlsim
-	$(MAKE) -C sgemv run-rtlsim
-	$(MAKE) -C sgemm2 run-rtlsim
-	$(MAKE) -C madmax run-rtlsim
-	$(MAKE) -C stencil3d run-rtlsim
+SRCS := $(SRC_DIR)/main.cpp
 
-clean:
-	$(MAKE) -C basic clean
-	$(MAKE) -C demo clean
-	$(MAKE) -C dogfood clean
-	$(MAKE) -C dropout clean
-	$(MAKE) -C dotproduct clean
-	$(MAKE) -C mstress clean
-	$(MAKE) -C io_addr clean
-	$(MAKE) -C printf clean
-	$(MAKE) -C diverge clean
-	$(MAKE) -C sort clean
-	$(MAKE) -C fence clean
-	$(MAKE) -C vecadd clean
-	$(MAKE) -C sgemm clean
-	$(MAKE) -C conv3 clean
-	$(MAKE) -C relu clean
-	$(MAKE) -C sgemv clean
-	$(MAKE) -C sgemm2 clean
-	$(MAKE) -C madmax clean
-	$(MAKE) -C stencil3d clean
+VX_SRCS := $(SRC_DIR)/kernel.cpp
+
+OPTS ?= -n32
+
+include ../common.mk
\ No newline at end of file
diff --git a/tests/regression/sgemm/Makefile b/tests/regression/sgemm/Makefile
deleted file mode 100644
index 1c19fca..0000000
--- a/tests/regression/sgemm/Makefile
+++ /dev/null
@@ -1,14 +0,0 @@
-ROOT_DIR := $(realpath ../../..)
-include $(ROOT_DIR)/config.mk
-
-PROJECT := sgemm
-
-SRC_DIR := $(VORTEX_HOME)/tests/regression/$(PROJECT)
-
-SRCS := $(SRC_DIR)/main.cpp
-
-VX_SRCS := $(SRC_DIR)/kernel.cpp
-
-OPTS ?= -n32
-
-include ../common.mk
\ No newline at end of file
diff --git a/tests/regression/sgemm/common.h b/tests/regression/sgemm/common.h
deleted file mode 100644
index b58ec5f..0000000
--- a/tests/regression/sgemm/common.h
+++ /dev/null
@@ -1,16 +0,0 @@
-#ifndef _COMMON_H_
-#define _COMMON_H_
-
-#ifndef TYPE
-#define TYPE float
-#endif
-
-typedef struct {
-  uint32_t grid_dim[2];
-  uint32_t size;
-  uint64_t A_addr;
-  uint64_t B_addr;
-  uint64_t C_addr;
-} kernel_arg_t;
-
-#endif
diff --git a/tests/regression/sgemm/kernel.cpp b/tests/regression/sgemm/kernel.cpp
deleted file mode 100644
index 5b67113..0000000
--- a/tests/regression/sgemm/kernel.cpp
+++ /dev/null
@@ -1,24 +0,0 @@
-#include <vx_spawn.h>
-#include "common.h"
-
-void kernel_body(kernel_arg_t* __UNIFORM__ arg) {
-	auto A = reinterpret_cast<TYPE*>(arg->A_addr);
-	auto B = reinterpret_cast<TYPE*>(arg->B_addr);
-	auto C = reinterpret_cast<TYPE*>(arg->C_addr);
-    auto size = arg->size;
-
-    int col = blockIdx.x;
-    int row = blockIdx.y;
-
-    TYPE sum(0);
-    for (int e = 0; e < size; ++e) {
-        sum += A[row * size + e] * B[e * size + col];
-    }
-
-    C[row * size + col] = sum;
-}
-
-int main() {
-	kernel_arg_t* arg = (kernel_arg_t*)csr_read(VX_CSR_MSCRATCH);
-	return vx_spawn_threads(2, arg->grid_dim, nullptr, (vx_kernel_func_cb)kernel_body, arg);
-}
diff --git a/tests/regression/sgemm/main.cpp b/tests/regression/sgemm/main.cpp
deleted file mode 100644
index 1fd97c5..0000000
--- a/tests/regression/sgemm/main.cpp
+++ /dev/null
@@ -1,239 +0,0 @@
-#include <iostream>
-#include <unistd.h>
-#include <string.h>
-#include <vector>
-#include <chrono>
-#include <vortex.h>
-#include <cmath>
-#include "common.h"
-
-#define FLOAT_ULP 6
-
-#define RT_CHECK(_expr)                                         \
-   do {                                                         \
-     int _ret = _expr;                                          \
-     if (0 == _ret)                                             \
-       break;                                                   \
-     printf("Error: '%s' returned %d!\n", #_expr, (int)_ret);   \
-	 cleanup();			                                              \
-     exit(-1);                                                  \
-   } while (false)
-
-///////////////////////////////////////////////////////////////////////////////
-
-template <typename Type>
-class Comparator {};
-
-template <>
-class Comparator<int> {
-public:
-  static const char* type_str() {
-    return "integer";
-  }
-  static int generate() {
-    return rand();
-  }
-  static bool compare(int a, int b, int index, int errors) {
-    if (a != b) {
-      if (errors < 100) {
-        printf("*** error: [%d] expected=%d, actual=%d\n", index, b, a);
-      }
-      return false;
-    }
-    return true;
-  }
-};
-
-template <>
-class Comparator<float> {
-public:
-  static const char* type_str() {
-    return "float";
-  }
-  static float generate() {
-    return static_cast<float>(rand()) / RAND_MAX;
-  }
-  static bool compare(float a, float b, int index, int errors) {
-    union fi_t { float f; int32_t i; };
-    fi_t fa, fb;
-    fa.f = a;
-    fb.f = b;
-    auto d = std::abs(fa.i - fb.i);
-    if (d > FLOAT_ULP) {
-      if (errors < 100) {
-        printf("*** error: [%d] expected=%f, actual=%f\n", index, b, a);
-      }
-      return false;
-    }
-    return true;
-  }
-};
-
-static void matmul_cpu(TYPE* out, const TYPE* A, const TYPE* B, uint32_t width, uint32_t height) {
-  for (uint32_t row = 0; row < height; ++row) {
-    for (uint32_t col = 0; col < width; ++col) {
-      TYPE sum(0);
-      for (uint32_t e = 0; e < width; ++e) {
-          sum += A[row * width + e] * B[e * width + col];
-      }
-      out[row * width + col] = sum;
-    }
-  }
-}
-
-const char* kernel_file = "kernel.vxbin";
-uint32_t size = 32;
-
-vx_device_h device = nullptr;
-vx_buffer_h A_buffer = nullptr;
-vx_buffer_h B_buffer = nullptr;
-vx_buffer_h C_buffer = nullptr;
-vx_buffer_h krnl_buffer = nullptr;
-vx_buffer_h args_buffer = nullptr;
-kernel_arg_t kernel_arg = {};
-
-static void show_usage() {
-   std::cout << "Vortex Test." << std::endl;
-   std::cout << "Usage: [-k: kernel] [-n size] [-h: help]" << std::endl;
-}
-
-static void parse_args(int argc, char **argv) {
-  int c;
-  while ((c = getopt(argc, argv, "n:k:h")) != -1) {
-    switch (c) {
-    case 'n':
-      size = atoi(optarg);
-      break;
-    case 'k':
-      kernel_file = optarg;
-      break;
-    case 'h':
-      show_usage();
-      exit(0);
-      break;
-    default:
-      show_usage();
-      exit(-1);
-    }
-  }
-}
-
-void cleanup() {
-  if (device) {
-    vx_mem_free(A_buffer);
-    vx_mem_free(B_buffer);
-    vx_mem_free(C_buffer);
-    vx_mem_free(krnl_buffer);
-    vx_mem_free(args_buffer);
-    vx_dev_close(device);
-  }
-}
-
-int main(int argc, char *argv[]) {
-  // parse command arguments
-  parse_args(argc, argv);
-
-  std::srand(50);
-
-  // open device connection
-  std::cout << "open device connection" << std::endl;
-  RT_CHECK(vx_dev_open(&device));
-
-  uint32_t size_sq = size * size;
-  uint32_t buf_size = size_sq * sizeof(TYPE);
-
-  std::cout << "data type: " << Comparator<TYPE>::type_str() << std::endl;
-  std::cout << "matrix size: " << size << "x" << size << std::endl;
-
-  kernel_arg.grid_dim[0] = size;
-  kernel_arg.grid_dim[1] = size;
-  kernel_arg.size = size;
-
-  // allocate device memory
-  std::cout << "allocate device memory" << std::endl;
-  RT_CHECK(vx_mem_alloc(device, buf_size, VX_MEM_READ, &A_buffer));
-  RT_CHECK(vx_mem_address(A_buffer, &kernel_arg.A_addr));
-  RT_CHECK(vx_mem_alloc(device, buf_size, VX_MEM_READ, &B_buffer));
-  RT_CHECK(vx_mem_address(B_buffer, &kernel_arg.B_addr));
-  RT_CHECK(vx_mem_alloc(device, buf_size, VX_MEM_WRITE, &C_buffer));
-  RT_CHECK(vx_mem_address(C_buffer, &kernel_arg.C_addr));
-
-  std::cout << "A_addr=0x" << std::hex << kernel_arg.A_addr << std::endl;
-  std::cout << "B_addr=0x" << std::hex << kernel_arg.B_addr << std::endl;
-  std::cout << "C_addr=0x" << std::hex << kernel_arg.C_addr << std::endl;
-
-  // generate source data
-  std::vector<TYPE> h_A(size_sq);
-  std::vector<TYPE> h_B(size_sq);
-  std::vector<TYPE> h_C(size_sq);
-  for (uint32_t i = 0; i < size_sq; ++i) {
-    h_A[i] = Comparator<TYPE>::generate();
-    h_B[i] = Comparator<TYPE>::generate();
-  }
-
-  // upload matrix A buffer
-  {
-    std::cout << "upload matrix A buffer" << std::endl;
-    RT_CHECK(vx_copy_to_dev(A_buffer, h_A.data(), 0, buf_size));
-  }
-
-  // upload matrix B buffer
-  {
-    std::cout << "upload matrix B buffer" << std::endl;
-    RT_CHECK(vx_copy_to_dev(B_buffer, h_B.data(), 0, buf_size));
-  }
-
-  // Upload kernel binary
-  std::cout << "Upload kernel binary" << std::endl;
-  RT_CHECK(vx_upload_kernel_file(device, kernel_file, &krnl_buffer));
-
-  // upload kernel argument
-  std::cout << "upload kernel argument" << std::endl;
-  RT_CHECK(vx_upload_bytes(device, &kernel_arg, sizeof(kernel_arg_t), &args_buffer));
-
-  auto time_start = std::chrono::high_resolution_clock::now();
-
-  // start device
-  std::cout << "start device" << std::endl;
-  RT_CHECK(vx_start(device, krnl_buffer, args_buffer));
-
-  // wait for completion
-  std::cout << "wait for completion" << std::endl;
-  RT_CHECK(vx_ready_wait(device, VX_MAX_TIMEOUT));
-
-  auto time_end = std::chrono::high_resolution_clock::now();
-  double elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(time_end - time_start).count();
-  printf("Elapsed time: %lg ms\n", elapsed);
-
-  // download destination buffer
-  std::cout << "download destination buffer" << std::endl;
-  RT_CHECK(vx_copy_from_dev(h_C.data(), C_buffer, 0, buf_size));
-
-  // verify result
-  std::cout << "verify result" << std::endl;
-  int errors = 0;
-  {
-    std::vector<TYPE> h_ref(size_sq);
-    matmul_cpu(h_ref.data(), h_A.data(), h_B.data(), size, size);
-
-    for (uint32_t i = 0; i < h_ref.size(); ++i) {
-      if (!Comparator<TYPE>::compare(h_C[i], h_ref[i], i, errors)) {
-        ++errors;
-      }
-    }
-  }
-
-  // cleanup
-  std::cout << "cleanup" << std::endl;
-  cleanup();
-
-  if (errors != 0) {
-    std::cout << "Found " << std::dec << errors << " errors!" << std::endl;
-    std::cout << "FAILED!" << std::endl;
-    return errors;
-  }
-
-  std::cout << "PASSED!" << std::endl;
-
-  return 0;
-}
\ No newline at end of file
