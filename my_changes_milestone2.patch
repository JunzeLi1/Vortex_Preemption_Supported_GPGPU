diff --git a/sim/simx/core.h b/sim/simx/core.h
index a8b674d..4f569d3 100644
--- a/sim/simx/core.h
+++ b/sim/simx/core.h
@@ -150,7 +150,7 @@ public:
   const MemCoalescer::Ptr& mem_coalescer(uint32_t idx) const {
     return mem_coalescers_.at(idx);
   }
-
+  
   void dcache_read(void* data, uint64_t addr, uint32_t size) {
     return emulator_.dcache_read(data, addr, size);
   }
diff --git a/sim/simx/emulator.cpp b/sim/simx/emulator.cpp
index 35fe248..5881547 100644
--- a/sim/simx/emulator.cpp
+++ b/sim/simx/emulator.cpp
@@ -93,6 +93,14 @@ Emulator::Emulator(const Arch &arch, const DCRS &dcrs, Core* core)
 {
   std::srand(50);
   this->reset();
+
+  for (auto &f : warp_faults_) {
+    f = warp_fault_state_t(); // pending=false, cause=None, etc.
+  }
+
+  for (auto &c : warp_inflight_) {
+    c = 0;
+  }
 }
 
 Emulator::~Emulator() {
@@ -131,6 +139,23 @@ void Emulator::reset() {
   active_warps_.set(0);
   warps_[0].tmask.set(0);
   wspawn_.valid = false;
+
+  // ---- new: clear page-fault + replay state ----
+  for (auto &f : warp_faults_) {
+    f = warp_fault_state_t(); // pending=false, cause=None, tval=0, uuid=0
+  }
+  for (auto &q : replay_queues_) {
+    q.clear();
+  }
+  for (auto &b : replay_pending_) {
+    b = false;
+  }
+  for (auto &b : replay_mode_) {
+    b = false;
+  }
+  for (auto &c : warp_inflight_) {
+    c = 0;
+  }
 }
 
 void Emulator::attach_ram(RAM* ram) {
@@ -142,11 +167,11 @@ void Emulator::attach_ram(RAM* ram) {
 #endif
 }
 
-void Emulator::raise_trap(uint32_t wid, ExcCause cause, Word tval) {
+void Emulator::raise_trap(uint32_t wid, ExcCause cause, Word tval, Word fault_pc) {
   auto& warp = warps_.at(wid);
 
   // Save faulting PC (PC of the instruction that caused the trap)
-  warp.csr.sepc   = warp.PC;
+  warp.csr.sepc   = fault_pc;
   warp.csr.scause = static_cast<Word>(cause);
   warp.csr.stval  = static_cast<Word>(tval);
 
@@ -191,8 +216,68 @@ void Emulator::return_from_trap(uint32_t wid) {
 
   // Clear any left-over micro-ops from handler
   warp.ibuffer.clear();
+
+#ifdef VM_ENABLE
+  // If this trap came from a page fault (Step 1/2), we should now replay.
+  if (replay_pending_[wid] && !replay_queues_[wid].empty()) {
+    DP(1, "return_from_trap: enabling replay mode for warp " << wid);
+    replay_mode_[wid] = true;
+  }
+#endif  
+}
+
+void Emulator::on_page_fault(uint32_t wid,
+                             uint64_t uuid,
+                             ExcCause cause,
+                             Word tval) {
+  auto& f = warp_faults_.at(wid);
+
+  // Step 1 / Step 2 assumption: at most one in-flight fault per warp
+  if (f.pending) {
+    DP(1, "on_page_fault: warp " << wid << " already has a pending fault, ignoring new one");
+    return;
+  }
+
+  f.pending = true;
+  f.cause   = cause;
+  f.tval    = tval;
+  f.uuid    = uuid;
+  f.pc      = warps_.at(wid).PC; // PC of the faulting instruction
+
+  // Allocate the minimal replay queue entry for this faulting instruction.
+  // Step 1: this is effectively a single-entry RQ.
+  // Step 2: replay_queues_[wid] can hold more entries, but we start with just this one.
+  replay_queues_[wid].clear();
+  replay_entry_t rq;
+  rq.pc       = f.pc;
+  rq.uuid     = uuid;
+  rq.is_store = (cause == ExcCause::StorePageFault);
+  replay_queues_[wid].push_back(rq);
+  replay_pending_[wid] = true;
+
+  DP(1, "on_page_fault: wid=" << wid
+        << " uuid=" << uuid
+        << " cause=" << cause
+        << " tval=0x" << std::hex << tval << std::dec);
+}
+
+bool Emulator::has_pending_fault(uint32_t wid) const {
+  return warp_faults_[wid].pending;
 }
 
+warp_fault_state_t Emulator::consume_fault(uint32_t wid) {
+  auto& f = warp_faults_.at(wid);
+  warp_fault_state_t out = f;
+  f.pending = false;
+  f.cause   = ExcCause::None;
+  f.tval    = 0;
+  f.uuid    = 0;
+  f.pc      = 0;
+  return out;
+}
+
+
+
 uint32_t Emulator::fetch(uint32_t wid, uint64_t uuid) {
   auto& warp = warps_.at(wid);
   __unused(uuid);
@@ -200,6 +285,7 @@ uint32_t Emulator::fetch(uint32_t wid, uint64_t uuid) {
   uint32_t instr_code = 0;
   this->icache_read(&instr_code, warp.PC, sizeof(uint32_t));
 
+  warp_inflight_[wid]++;
   DP(1, "Fetch: code=0x" << std::hex << instr_code << std::dec << ", cid=" << core_->id() << ", wid=" << wid << ", tmask=" << warp.tmask
          << ", PC=0x" << std::hex << warp.PC << " (#" << std::dec << uuid << ")");
   return instr_code;
@@ -238,6 +324,97 @@ instr_trace_t* Emulator::step() {
   auto& warp = warps_.at(scheduled_warp);
   assert(warp.tmask.any());
 
+#ifdef VM_ENABLE
+  // =========================================================
+  // 1) Replay mode: feed from replay_queue instead of normal
+  //    fetch when we have outstanding replays after SRET.
+  // =========================================================
+  if (replay_mode_[scheduled_warp]) {
+    auto &rq = replay_queues_[scheduled_warp];
+
+    if (rq.empty()) {
+      // Nothing left to replay; exit replay mode and continue normally
+      replay_mode_[scheduled_warp]    = false;
+      replay_pending_[scheduled_warp] = false;
+    } else {
+      auto &entry = rq.front();
+
+      // Force PC to the replay PC and flush stale ibuffer contents
+      if (warp.PC != entry.pc) {
+        DP(2, "replay: wid=" << scheduled_warp
+              << " pc=0x" << std::hex << entry.pc << std::dec);
+        warp.PC = entry.pc;
+        warp.ibuffer.clear();
+      }
+
+      // Normal fetch/decode/execute for this one instruction
+      if (warp.ibuffer.empty()) {
+        uint64_t uuid = entry.uuid;
+#ifndef NDEBUG
+        // If we didn't preserve the uuid for some reason, regenerate a fresh one
+        if (!uuid) {
+          uint32_t instr_uuid = warp.uuid++;
+          uint32_t g_wid = core_->id() * arch_.num_warps() + scheduled_warp;
+          uuid = (uint64_t(g_wid) << 32) | instr_uuid;
+        }
+#endif
+        auto instr_code = this->fetch(scheduled_warp, uuid);
+        this->decode(instr_code, scheduled_warp, uuid);
+        // We treat each replayed macro-instruction as one "in-flight"
+        if (warp_inflight_[scheduled_warp] < UINT32_MAX)
+          ++warp_inflight_[scheduled_warp];
+      } else {
+        // PC was already advanced in the previous cycle; compensate
+        warp.PC -= 4;
+      }
+
+      auto instr = warp.ibuffer.back();
+      warp.ibuffer.pop_back();
+
+      auto trace = this->execute(*instr, scheduled_warp);
+
+      if (warp_inflight_[scheduled_warp] > 0)
+        --warp_inflight_[scheduled_warp];
+
+      // This replay entry has now been executed once
+      rq.pop_front();
+
+      if (rq.empty()) {
+        replay_mode_[scheduled_warp]    = false;
+        replay_pending_[scheduled_warp] = false;
+      }
+
+      return trace;
+    }
+  }
+
+  // =========================================================
+  // 2) Pending page fault: stall this warp until its current
+  //    instruction finishes and then raise the trap.
+  // =========================================================
+  if (this->has_pending_fault(scheduled_warp) && !warp.in_trap_handler) {
+    DP(2, "step: warp " << scheduled_warp
+                         << " has pending fault, inflight="
+                         << warp_inflight_[scheduled_warp]);
+
+    if (warp_inflight_[scheduled_warp] == 0) {
+      // Safe point: all previous instructions for this warp are done.
+      auto fault = this->consume_fault(scheduled_warp);
+      DP(1, "step: taking trap for warp " << scheduled_warp
+               << " cause=" << fault.cause
+               << " tval=0x" << std::hex << fault.tval << std::dec);
+      this->raise_trap(scheduled_warp, fault.cause, fault.tval, fault.pc);
+
+      // Don't execute a normal instruction this cycle;
+      // next step() will start fetching from stvec.
+      return nullptr;
+    }
+
+    // Still draining in-flight work for this warp; don't issue new work.
+    return nullptr;
+  }
+#endif
+
   // fetch next instruction if ibuffer is empty
   if (warp.ibuffer.empty()) {
     uint64_t uuid = 0;
@@ -255,6 +432,12 @@ instr_trace_t* Emulator::step() {
 
     // decode
     this->decode(instr_code, scheduled_warp, uuid);
+
+#ifdef VM_ENABLE
+    // One more macro-instruction "in-flight" for this warp.
+    if (warp_inflight_[scheduled_warp] < UINT32_MAX)
+      ++warp_inflight_[scheduled_warp];
+#endif
   } else {
     // we have a micro-instruction in the ibuffer
     // adjust PC back to original (incremented in execute())
@@ -268,6 +451,15 @@ instr_trace_t* Emulator::step() {
   // Execute
   auto trace = this->execute(*instr, scheduled_warp);
 
+#ifdef VM_ENABLE
+  // One macro-instruction worth of work is now retired for this warp.
+  // (SimX models memory effects synchronously at execute() time,
+  // so this is accurate enough for "drain then trap".)
+  if (warp_inflight_[scheduled_warp] > 0) {
+    --warp_inflight_[scheduled_warp];
+  }
+#endif
+
   return trace;
 }
 
@@ -364,7 +556,8 @@ void Emulator::set_satp(uint64_t satp) {
 
 
 #ifdef VM_ENABLE
-void Emulator::dcache_read(void *data, uint64_t addr, uint32_t size) {
+void Emulator::dcache_read(void *data, uint64_t addr, uint32_t size,
+                           uint32_t wid, uint64_t uuid) {
   DP(1, "*** dcache_read 0x" << std::hex << addr << ", size = 0x "  << size);
   auto type = get_addr_type(addr);
   if (type == AddrType::Shared) {
@@ -377,7 +570,14 @@ void Emulator::dcache_read(void *data, uint64_t addr, uint32_t size) {
     catch (Page_Fault_Exception& page_fault)
     {
       std::cout<<page_fault.what()<<std::endl;
-      throw;
+      // Register the fault – minimal version: uuid not used yet
+      this->on_page_fault(wid,
+                          uuid,                      // can be 0 for now
+                          ExcCause::LoadPageFault,   // or InstrPageFault if this was an I-fetch
+                          addr);
+      // For now: zero-fill the load result so later pipeline stages don't use garbage
+      std::memset(data, 0, size);
+      return;
     }
   }
   DPH(2, "Mem Read: addr=0x" << std::hex << addr << ", data=0x" << ByteStream(data, size) << " (size=" << size << ", type=" << type << ")" << std::endl);
@@ -395,7 +595,8 @@ void Emulator::dcache_read(void *data, uint64_t addr, uint32_t size) {
 #endif
 
 #ifdef VM_ENABLE
-void Emulator::dcache_write(const void* data, uint64_t addr, uint32_t size) {
+void Emulator::dcache_write(const void* data, uint64_t addr, uint32_t size,
+                            uint32_t wid, uint64_t uuid){
   DP(1, "*** dcache_write 0x" << std::hex << addr << ", size = 0x "  << size);
   auto type = get_addr_type(addr);
   if (addr >= uint64_t(IO_COUT_ADDR)
@@ -413,7 +614,11 @@ void Emulator::dcache_write(const void* data, uint64_t addr, uint32_t size) {
       catch (Page_Fault_Exception& page_fault)
       {
         std::cout<<page_fault.what()<<std::endl;
-        throw;
+        this->on_page_fault(wid,
+                            uuid,
+                            ExcCause::StorePageFault,
+                            addr);
+        return;
       }
     }
   }
@@ -708,9 +913,9 @@ void Emulator::update_fcrs(uint32_t fflags, uint32_t wid, uint32_t tid) {
 // For now, we need these instructions to trap for testing the riscv-vector isa
 void Emulator::trigger_ecall(uint32_t wid) {
   // Treat every ECALL as an S-mode ecall for now
-  this->raise_trap(wid, ExcCause::EcallFromSMode, 0);
+  this->raise_trap(wid, ExcCause::EcallFromSMode, 0, warps_.at(wid).PC);
 }
 
 void Emulator::trigger_ebreak(uint32_t wid) {
-  this->raise_trap(wid, ExcCause::Breakpoint, 0);
+  this->raise_trap(wid, ExcCause::Breakpoint, 0, warps_.at(wid).PC);
 }
\ No newline at end of file
diff --git a/sim/simx/emulator.h b/sim/simx/emulator.h
index 8cee6bb..26d846d 100644
--- a/sim/simx/emulator.h
+++ b/sim/simx/emulator.h
@@ -20,6 +20,7 @@
 #include <mem.h>
 #include "types.h"
 #include "instr.h"
+#include <array>
 #ifdef EXT_TCU_ENABLE
 #include "tensor_unit.h"
 #endif
@@ -72,6 +73,33 @@ struct warp_csr_state_t {
 
 ///////////////////////////////////////////////////////////////////////////////
 
+struct warp_fault_state_t {
+  bool        pending;
+  ExcCause    cause;
+  Word        tval;   // usually the faulting VA
+  uint64_t    uuid;   // dynamic instruction UUID (from decode)
+  Word        pc;     // PC of the macro-instruction that faulted
+
+  warp_fault_state_t()
+    : pending(false)
+    , cause(ExcCause::None)
+    , tval(0)
+    , uuid(0)
+    , pc(0)
+  {}
+};
+
+struct replay_entry_t {
+  Word     pc;       // PC of the instruction we will replay
+  uint64_t uuid;     // original instruction UUID (for debug / tracing)
+  bool     is_store; // load vs store (debug / future stats)
+
+  replay_entry_t()
+    : pc(0)
+    , uuid(0)
+    , is_store(false)
+  {}
+};
 
 
 ///////////////////////////////////////////////////////////////////////////////
@@ -116,7 +144,7 @@ public:
 
   void attach_ram(RAM* ram);
 
-  void raise_trap(uint32_t wid, ExcCause cause, Word tval);
+  void raise_trap(uint32_t wid, ExcCause cause, Word tval, Word fault_pc);
 
   void return_from_trap(uint32_t wid);
 
@@ -138,12 +166,44 @@ public:
 
   int get_exitcode() const;
 
+#ifdef VM_ENABLE
+  void dcache_read(void *data, uint64_t addr, uint32_t size,
+                   uint32_t wid, uint64_t uuid);
+  void dcache_write(const void* data, uint64_t addr, uint32_t size,
+                    uint32_t wid, uint64_t uuid);
+#else
   void dcache_read(void* data, uint64_t addr, uint32_t size);
 
   void dcache_write(const void* data, uint64_t addr, uint32_t size);
+#endif
+
+  void on_page_fault(uint32_t wid,
+                     uint64_t uuid,
+                     ExcCause cause,
+                     Word tval);
 
+  bool has_pending_fault(uint32_t wid) const;
+
+  warp_fault_state_t consume_fault(uint32_t wid);
+  
 private:
 
+  // Per-warp pending-trap info (Step 1)
+  std::array<warp_fault_state_t, NUM_WARPS> warp_faults_;
+  
+  // Per-warp replay queue (Step 2: can hold many entries)
+  std::array<std::deque<replay_entry_t>, NUM_WARPS> replay_queues_;
+  
+  // Set when we know we must perform replay after the trap handler returns.
+  std::array<bool, NUM_WARPS> replay_pending_;
+
+  // Set when we are *currently* feeding instructions from replay_queues_.
+  std::array<bool, NUM_WARPS> replay_mode_;
+
+  // Approximate “in-flight” instruction counter per warp
+  // (we only really need 0 vs non-0 for drain-before-trap logic).
+  std::array<uint32_t, NUM_WARPS> warp_inflight_;
+
   uint32_t fetch(uint32_t wid, uint64_t uuid);
 
   void decode(uint32_t code, uint32_t wid, uint64_t uuid);
