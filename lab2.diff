diff --git a/hw/rtl/tcu/VX_tcu_fedp_bhf.sv b/hw/rtl/tcu/VX_tcu_fedp_bhf.sv
index d11cfc0..80c1989 100644
--- a/hw/rtl/tcu/VX_tcu_fedp_bhf.sv
+++ b/hw/rtl/tcu/VX_tcu_fedp_bhf.sv
@@ -75,6 +75,7 @@ module VX_tcu_fedp_bhf #(
     for (genvar i = 0; i < TCK; i++) begin : g_prod
         wire [32:0] mult_result_fp16;
         wire [32:0] mult_result_bf16;
+        wire [32:0] mult_result_tf32;
 
         // FP16 multiplication
         VX_tcu_bhf_fmul #(
@@ -118,11 +119,39 @@ module VX_tcu_fedp_bhf #(
             `UNUSED_PIN(fflags)
         );
 
+        if(0 == (i % 2)) begin : g_tf32_even
+            localparam int TF32_IDX = i / 2;
+
+            // TF32 multiplication
+            VX_tcu_bhf_fmul #(
+                .IN_EXPW (8),
+                .IN_SIGW (10+1),
+                .OUT_EXPW(8),
+                .OUT_SIGW(24),
+                .IN_REC  (0), // input in IEEE format
+                .OUT_REC (1), // output in recoded format
+                .MUL_LATENCY (FMUL_LATENCY),
+                .RND_LATENCY (FRND_LATENCY)
+            ) tf32_mul (
+                .clk    (clk),
+                .reset  (reset),
+                .enable (enable),
+                .frm    (frm),
+                .a      (a_row[TF32_IDX][18:0]),
+                .b      (b_col[TF32_IDX][18:0]),
+                .y      (mult_result_tf32),
+                `UNUSED_PIN(fflags)
+            );
+        end else begin : g_tf32_odd
+            assign mult_result_tf32 = '0;
+        end
+
         logic [32:0] mult_result_mux;
         always_comb begin
             case(fmt_s_delayed)
                 3'd1: mult_result_mux = mult_result_fp16;
                 3'd2: mult_result_mux = mult_result_bf16;
+                3'd3: mult_result_mux = mult_result_tf32;
                 default: mult_result_mux = 'x;
             endcase
         end
diff --git a/hw/rtl/tcu/VX_tcu_pkg.sv b/hw/rtl/tcu/VX_tcu_pkg.sv
index bd82aaa..f6c68a1 100644
--- a/hw/rtl/tcu/VX_tcu_pkg.sv
+++ b/hw/rtl/tcu/VX_tcu_pkg.sv
@@ -34,6 +34,7 @@ package VX_tcu_pkg;
     localparam TCU_U8_ID   = 10;
     localparam TCU_I4_ID   = 11;
     localparam TCU_U4_ID   = 12;
+    localparam TCU_TF32_ID = 3;
 
     // Tile dimensions
     localparam TCU_TILE_CAP = TCU_NT * TCU_NR;
@@ -84,6 +85,7 @@ package VX_tcu_pkg;
 `ifdef SIMULATION
     task trace_fmt(input int level, input [3:0] fmt);
         case (fmt)
+            TCU_TF32_ID: `TRACE(level, ("tf32"))
             TCU_FP32_ID: `TRACE(level, ("fp32"))
             TCU_FP16_ID: `TRACE(level, ("fp16"))
             TCU_BF16_ID: `TRACE(level, ("bf16"))
diff --git a/sim/common/tensor_cfg.h b/sim/common/tensor_cfg.h
index 4e0a3dd..4f39394 100644
--- a/sim/common/tensor_cfg.h
+++ b/sim/common/tensor_cfg.h
@@ -78,12 +78,12 @@ struct uint4 {
   static constexpr const char* name = "u4";
 };
 
-// struct tf32 {
-//   using dtype = uint32_t;
-//   static constexpr uint32_t id = 3;
-//   static constexpr uint32_t bits = 32;
-//   static constexpr const char* name = "tf32";
-// }
+struct tf32 {
+  using dtype = uint32_t;
+  static constexpr uint32_t id = 3;
+  static constexpr uint32_t bits = 32;
+  static constexpr const char* name = "tf32";
+};
 
 inline const char* fmt_string(uint32_t fmt) {
   switch (fmt) {
diff --git a/sim/simx/tensor_unit.cpp b/sim/simx/tensor_unit.cpp
index 1bb6da3..20e303a 100644
--- a/sim/simx/tensor_unit.cpp
+++ b/sim/simx/tensor_unit.cpp
@@ -83,6 +83,19 @@ struct FMA<vt::bf16, vt::bf16> {
   }
 };
 
+template <>
+struct FMA<vt::tf32, vt::fp32> {
+  static float eval(uint32_t a, uint32_t b, float c) {
+    auto a_bits = rv_xtof_s(a, 8, 10, 0, nullptr);
+    auto b_bits = rv_xtof_s(b, 8, 10, 0, nullptr);
+
+    float af = bit_cast<float>(a_bits);
+    float bf = bit_cast<float>(b_bits);
+    
+    return af * bf + c;
+  }
+};
+
 template <typename It, typename Ot>
 struct FEDP {
   using itype = typename It::dtype;
@@ -152,6 +165,8 @@ static PFN_FEDP select_FEDP(uint32_t IT, uint32_t OT) {
       return FEDP<vt::fp16, vt::fp32>::eval;
     case vt::bf16::id:
       return FEDP<vt::bf16, vt::fp32>::eval;
+    case vt::tf32::id:
+      return FEDP<vt::tf32, vt::fp32>::eval;
     default:
       std::cout << "Error: unsupported mma format: " << IT << " -> " << OT << "!" << std::endl;
       std::abort();
diff --git a/tests/regression/sgemm_tcu/main.cpp b/tests/regression/sgemm_tcu/main.cpp
index 132e412..dfca941 100644
--- a/tests/regression/sgemm_tcu/main.cpp
+++ b/tests/regression/sgemm_tcu/main.cpp
@@ -399,7 +399,7 @@ static void matmul_cpu(otype_t *C, const itype_t *A, const itype_t *B, uint32_t
 const char *kernel_file = "kernel.vxbin";
 
 uint32_t xm = 32;
-uint32_t xn = 32;
+uint32_t xn = 256;
 uint32_t xk = 32;
 
 vx_device_h device = nullptr;
