diff --git a/.gitignore b/.gitignore
index e188b4c..fab0a04 100644
--- a/.gitignore
+++ b/.gitignore
@@ -3,3 +3,4 @@
 *.cache
 *.code-workspace
 miscs/apptainer/vortex.sif
+tests/
diff --git a/sim/simx/emulator.cpp b/sim/simx/emulator.cpp
index 3eb62f9..63ab1e0 100644
--- a/sim/simx/emulator.cpp
+++ b/sim/simx/emulator.cpp
@@ -36,6 +36,8 @@ warp_t::warp_t(uint32_t num_threads)
   , tmask(num_threads)
   , PC(0)
   , uuid(0)
+  , csr()
+  , in_trap_handler(false)
 {}
 
 void warp_t::reset(uint64_t startup_addr) {
@@ -44,6 +46,9 @@ void warp_t::reset(uint64_t startup_addr) {
   this->uuid = 0;
   this->fcsr = 0;
 
+  this->csr = warp_csr_state_t();
+  this->in_trap_handler = false;
+
   for (auto& reg_file : this->ireg_file) {
     for (auto& reg : reg_file) {
     #ifndef NDEBUG
@@ -137,6 +142,57 @@ void Emulator::attach_ram(RAM* ram) {
 #endif
 }
 
+void Emulator::raise_trap(uint32_t wid, ExcCause cause, uint64_t tval) {
+  auto& warp = warps_.at(wid);
+
+  // Save faulting PC (PC of the instruction that caused the trap)
+  warp.csr.sepc   = warp.PC;
+  warp.csr.scause = static_cast<Word>(cause);
+  warp.csr.stval  = static_cast<Word>(tval);
+
+  warp.in_trap_handler = true;
+
+  // If no handler is installed, fall back to killing the warp
+  if (warp.csr.stvec == 0) {
+    DP(1, "raise_trap: wid=" << wid
+          << " cause=" << cause
+          << " with stvec=0, killing warp");
+    active_warps_.reset(wid);
+    stalled_warps_.reset(wid);
+    return;
+  }
+
+  DP(1, "raise_trap: wid=" << wid
+        << " cause=" << cause
+        << " sepc=0x" << std::hex << warp.csr.sepc
+        << " stvec=0x" << warp.csr.stvec
+        << " tval=0x" << tval << std::dec);
+
+  // Clear any remaining micro-ops from the old context
+  warp.ibuffer.clear();
+
+  // Optional: clear ipdom stack so trap executes as a straight-line region
+  while (!warp.ipdom_stack.empty()) {
+    warp.ipdom_stack.pop();
+  }
+
+  warp.PC = warp.csr.stvec;
+}
+
+void Emulator::return_from_trap(uint32_t wid) {
+  auto& warp = warps_.at(wid);
+
+  DP(1, "return_from_trap: wid=" << wid
+        << " sepc=0x" << std::hex << warp.csr.sepc << std::dec);
+
+  // Return to saved PC (faulting instruction PC); handler decides whether to replay or skip
+  warp.PC = warp.csr.sepc;
+  warp.in_trap_handler = false;
+
+  // Clear any left-over micro-ops from handler
+  warp.ibuffer.clear();
+}
+
 uint32_t Emulator::fetch(uint32_t wid, uint64_t uuid) {
   auto& warp = warps_.at(wid);
   __unused(uuid);
@@ -446,6 +502,13 @@ Word Emulator::get_csr(uint32_t addr, uint32_t wid, uint32_t tid) {
   case VX_CSR_MNSTATUS:
   case VX_CSR_MCAUSE:
     return 0;
+  
+  case csr::SSTATUS:  return warps_.at(wid).csr.sstatus;
+  case csr::STVEC:    return warps_.at(wid).csr.stvec;
+  case csr::SSCRATCH: return warps_.at(wid).csr.sscratch;
+  case csr::SEPC:     return warps_.at(wid).csr.sepc;
+  case csr::SCAUSE:   return warps_.at(wid).csr.scause;
+  case csr::STVAL:    return warps_.at(wid).csr.stval;
 
   case VX_CSR_FFLAGS: return warps_.at(wid).fcsr & 0x1F;
   case VX_CSR_FRM:    return (warps_.at(wid).fcsr >> 5);
@@ -569,6 +632,24 @@ Word Emulator::get_csr(uint32_t addr, uint32_t wid, uint32_t tid) {
 void Emulator::set_csr(uint32_t addr, Word value, uint32_t wid, uint32_t tid) {
   __unused (tid);
   switch (addr) {
+  case csr::SSTATUS:
+    warps_.at(wid).csr.sstatus = value;
+    break;
+  case csr::STVEC:
+    warps_.at(wid).csr.stvec = value;
+    break;
+  case csr::SSCRATCH:
+    warps_.at(wid).csr.sscratch = value;
+    break;
+  case csr::SEPC:
+    warps_.at(wid).csr.sepc = value;
+    break;
+  case csr::SCAUSE:
+    warps_.at(wid).csr.scause = value;
+    break;
+  case csr::STVAL:
+    warps_.at(wid).csr.stval = value;
+    break;
   case VX_CSR_FFLAGS:
     warps_.at(wid).fcsr = (warps_.at(wid).fcsr & ~0x1F) | (value & 0x1F);
     break;
@@ -625,9 +706,11 @@ void Emulator::update_fcrs(uint32_t fflags, uint32_t wid, uint32_t tid) {
 // Therefore, without these instructions, undefined and incorrect behavior happens
 //
 // For now, we need these instructions to trap for testing the riscv-vector isa
-void Emulator::trigger_ecall() {
-  active_warps_.reset();
-}
-void Emulator::trigger_ebreak() {
-  active_warps_.reset();
+void Emulator::trigger_ecall(uint32_t wid) {
+  // Treat every ECALL as an S-mode ecall for now
+  this->raise_trap(wid, ExcCause::EcallFromSMode, 0);
 }
+
+void Emulator::trigger_ebreak(uint32_t wid) {
+  this->raise_trap(wid, ExcCause::Breakpoint, 0);
+}
\ No newline at end of file
diff --git a/sim/simx/emulator.h b/sim/simx/emulator.h
index 0fb1e0b..713e71a 100644
--- a/sim/simx/emulator.h
+++ b/sim/simx/emulator.h
@@ -51,6 +51,29 @@ struct ipdom_entry_t {
 
 ///////////////////////////////////////////////////////////////////////////////
 
+struct warp_csr_state_t {
+  Word sstatus;
+  Word stvec;
+  Word sscratch;
+  Word sepc;
+  Word scause;
+  Word stval;
+
+  warp_csr_state_t()
+    : sstatus(0)
+    , stvec(0)
+    , sscratch(0)
+    , sepc(0)
+    , scause(0)
+    , stval(0)
+  {}
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+
+///////////////////////////////////////////////////////////////////////////////
+
 struct warp_t {
   std::vector<std::vector<Word>>    ireg_file;
   std::vector<std::vector<uint64_t>>freg_file;
@@ -61,6 +84,9 @@ struct warp_t {
   Byte                              fcsr;
   uint32_t                          uuid;
 
+  warp_csr_state_t                  csr;
+  bool                              in_trap_handler;
+
   warp_t(uint32_t num_threads);
 
   void reset(uint64_t startup_addr);
@@ -68,6 +94,7 @@ struct warp_t {
 
 ///////////////////////////////////////////////////////////////////////////////
 
+
 struct wspawn_t {
   bool      valid;
   uint32_t  num_warps;
@@ -86,6 +113,10 @@ public:
 
   void attach_ram(RAM* ram);
 
+  void raise_trap(uint32_t wid, ExcCause cause, Word tval);
+
+  void return_from_trap(uint32_t wid);
+
 #ifdef VM_ENABLE
   void set_satp(uint64_t satp) ;
 #endif
@@ -138,8 +169,9 @@ private:
 
   // temporarily added for riscv-vector tests
   // TODO: remove once ecall/ebreak are supported
-  void trigger_ecall();
-  void trigger_ebreak();
+  void trigger_ecall(uint32_t wid);
+  void trigger_ebreak(uint32_t wid);
+
 
   const Arch& arch_;
   const DCRS& dcrs_;
diff --git a/sim/simx/execute.cpp b/sim/simx/execute.cpp
index 4e3d880..9f0cf3d 100644
--- a/sim/simx/execute.cpp
+++ b/sim/simx/execute.cpp
@@ -168,6 +168,9 @@ instr_trace_t* Emulator::execute(const Instr &instr, uint32_t wid) {
 #endif // XLEN_64
 
   bool rd_write = false;
+  // control-flow override flags for traps
+  bool took_trap = false; // ECALL/EBREAK
+  bool did_sret  = false; // SRET/URET/MRET
 
   visit_var(op_type,
     [&](AluType alu_type) {
@@ -495,22 +498,30 @@ instr_trace_t* Emulator::execute(const Instr &instr, uint32_t wid) {
         trace->fetch_stall = true;
         rd_write = true;
       } break;
-      case BrType::SYS:
+      case BrType::SYS: {
+        // System instructions: ECALL/EBREAK/SRET
+        trace->fetch_stall = true;  // treat like a control-flow change
+
         switch (brArgs.offset) {
         case 0x000: // RV32I: ECALL
-          this->trigger_ecall();
+          this->trigger_ecall(wid);
+          took_trap = true;
           break;
         case 0x001: // RV32I: EBREAK
-          this->trigger_ebreak();
+          this->trigger_ebreak(wid);
+          took_trap = true;
           break;
         case 0x002: // RV32I: URET
         case 0x102: // RV32I: SRET
-        case 0x302: // RV32I: MRET
+        case 0x302: { // RV32I: MRET
+          this->return_from_trap(wid);
+          did_sret = true;
+        } 
           break;
         default:
           std::abort();
         }
-        break;
+      }break;
       default:
         std::abort();
       }
@@ -1554,11 +1565,22 @@ instr_trace_t* Emulator::execute(const Instr &instr, uint32_t wid) {
     }
   }
 
-  warp.PC += 4;
+  // warp.PC += 4;
+
+  // if (warp.PC != next_pc) {
+  //   DP(3, "*** Next PC=0x" << std::hex << next_pc << std::dec);
+  //   warp.PC = next_pc;
+  // }
 
-  if (warp.PC != next_pc) {
-    DP(3, "*** Next PC=0x" << std::hex << next_pc << std::dec);
-    warp.PC = next_pc;
+  if (!took_trap && !did_sret) {
+    warp.PC += 4;
+
+    if (warp.PC != next_pc) {
+      DP(3, "*** Next PC=0x" << std::hex << next_pc << std::dec);
+      warp.PC = next_pc;
+    }
+  } else {
+    DP(3, "*** PC set by trap/return: 0x" << std::hex << warp.PC << std::dec);
   }
 
   if (warp.tmask != next_tmask) {
diff --git a/sim/simx/types.h b/sim/simx/types.h
index e6904b1..e368732 100644
--- a/sim/simx/types.h
+++ b/sim/simx/types.h
@@ -479,6 +479,61 @@ inline std::ostream &operator<<(std::ostream &os, const CsrType& type) {
 
 ///////////////////////////////////////////////////////////////////////////////
 
+enum class ExcCause : uint32_t {
+  None                = 0xffffffffu,
+
+  InstrAddrMisaligned = 0,
+  InstrAccessFault    = 1,
+  IllegalInstr        = 2,
+  Breakpoint          = 3,
+  LoadAddrMisaligned  = 4,
+  LoadAccessFault     = 5,
+  StoreAddrMisaligned = 6,
+  StoreAccessFault    = 7,
+  EcallFromUMode      = 8,
+  EcallFromSMode      = 9,
+  EcallFromMMode      = 11,
+  InstrPageFault      = 12,
+  LoadPageFault       = 13,
+  StorePageFault      = 15,
+  GpuSyntheticFault   = 0x100
+};
+
+inline std::ostream &operator<<(std::ostream &os, const ExcCause& cause) {
+  switch (cause) {
+  case ExcCause::None:                os << "None"; break;
+  case ExcCause::InstrAddrMisaligned: os << "InstrAddrMisaligned"; break;
+  case ExcCause::InstrAccessFault:    os << "InstrAccessFault"; break;
+  case ExcCause::IllegalInstr:        os << "IllegalInstr"; break;
+  case ExcCause::Breakpoint:          os << "Breakpoint"; break;
+  case ExcCause::LoadAddrMisaligned:  os << "LoadAddrMisaligned"; break;
+  case ExcCause::LoadAccessFault:     os << "LoadAccessFault"; break;
+  case ExcCause::StoreAddrMisaligned: os << "StoreAddrMisaligned"; break;
+  case ExcCause::StoreAccessFault:    os << "StoreAccessFault"; break;
+  case ExcCause::EcallFromUMode:      os << "EcallFromUMode"; break;
+  case ExcCause::EcallFromSMode:      os << "EcallFromSMode"; break;
+  case ExcCause::EcallFromMMode:      os << "EcallFromMMode"; break;
+  case ExcCause::InstrPageFault:      os << "InstrPageFault"; break;
+  case ExcCause::LoadPageFault:       os << "LoadPageFault"; break;
+  case ExcCause::StorePageFault:      os << "StorePageFault"; break;
+  case ExcCause::GpuSyntheticFault:   os << "GpuSyntheticFault"; break;
+  default:
+    assert(false);
+  }
+  return os;
+}
+
+namespace csr {
+  static constexpr uint32_t SSTATUS  = 0x100;
+  static constexpr uint32_t STVEC    = 0x105;
+  static constexpr uint32_t SSCRATCH = 0x140;
+  static constexpr uint32_t SEPC     = 0x141;
+  static constexpr uint32_t SCAUSE   = 0x142;
+  static constexpr uint32_t STVAL    = 0x143;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
 enum class VsetType {
   VSETVLI,
   VSETIVLI,
